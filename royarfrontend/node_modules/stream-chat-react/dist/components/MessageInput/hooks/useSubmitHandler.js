var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
import { useChannelStateContext } from '../../../context/ChannelStateContext';
import { useChannelActionContext } from '../../../context/ChannelActionContext';
import { logChatPromiseExecution } from 'stream-chat';
/**
 * Get attachment type from MIME type
 */
var getAttachmentTypeFromMime = function (mime) {
    if (mime.includes('video/'))
        return 'video';
    if (mime.includes('audio/'))
        return 'audio';
    return 'file';
};
export var useSubmitHandler = function (props, state, dispatch, numberOfUploads) {
    var clearEditingState = props.clearEditingState, message = props.message, overrideSubmitHandler = props.overrideSubmitHandler, parent = props.parent, publishTypingEvent = props.publishTypingEvent;
    var attachments = state.attachments, fileOrder = state.fileOrder, fileUploads = state.fileUploads, imageOrder = state.imageOrder, imageUploads = state.imageUploads, mentioned_users = state.mentioned_users, text = state.text;
    var channel = useChannelStateContext().channel;
    var _a = useChannelActionContext(), editMessage = _a.editMessage, sendMessage = _a.sendMessage;
    var getAttachmentsFromUploads = function () {
        var imageAttachments = imageOrder
            .map(function (id) { return imageUploads[id]; })
            .filter(function (upload) { return upload.state !== 'failed'; })
            .filter(function (_a, _, self) {
            var id = _a.id, url = _a.url;
            return self.every(function (upload) { return upload.id === id || upload.url !== url; });
        })
            .map(function (upload) {
            return ({
                fallback: upload.file.name,
                image_url: upload.url,
                type: 'image',
            });
        });
        var fileAttachments = fileOrder
            .map(function (id) { return fileUploads[id]; })
            .filter(function (upload) { return upload.state !== 'failed'; })
            .map(function (upload) {
            return ({
                asset_url: upload.url,
                file_size: upload.file.size,
                mime_type: upload.file.type,
                title: upload.file.name,
                type: getAttachmentTypeFromMime(upload.file.type || ''),
            });
        });
        return __spreadArray(__spreadArray(__spreadArray([], attachments), imageAttachments), fileAttachments);
    };
    var handleSubmit = function (event) {
        event.preventDefault();
        var trimmedMessage = text.trim();
        var isEmptyMessage = trimmedMessage === '' ||
            trimmedMessage === '>' ||
            trimmedMessage === '``````' ||
            trimmedMessage === '``' ||
            trimmedMessage === '**' ||
            trimmedMessage === '____' ||
            trimmedMessage === '__' ||
            trimmedMessage === '****';
        if (isEmptyMessage && numberOfUploads === 0) {
            return;
        }
        // the channel component handles the actual sending of the message
        var someAttachmentsUploading = Object.values(imageUploads).some(function (upload) { return upload.state === 'uploading'; }) ||
            Object.values(fileUploads).some(function (upload) { return upload.state === 'uploading'; });
        if (someAttachmentsUploading) {
            // TODO: show error to user that they should wait until image is uploaded
            return;
        }
        var newAttachments = getAttachmentsFromUploads();
        // Instead of checking if a user is still mentioned every time the text changes,
        // just filter out non-mentioned users before submit, which is cheaper
        // and allows users to easily undo any accidental deletion
        var actualMentionedUsers = Array.from(new Set(mentioned_users.filter(function (_a) {
            var id = _a.id, name = _a.name;
            return text.includes("@" + id) || text.includes("@" + name);
        })));
        var updatedMessage = {
            attachments: newAttachments,
            mentioned_users: actualMentionedUsers,
            text: text,
        };
        if (!!message && editMessage) {
            // TODO: Remove this line and show an error when submit fails
            if (clearEditingState) {
                clearEditingState();
            }
            var updateMessagePromise = editMessage(__assign(__assign({}, updatedMessage), { id: message.id })).then(clearEditingState);
            logChatPromiseExecution(updateMessagePromise, 'update message');
            dispatch({ type: 'clear' });
        }
        else if (overrideSubmitHandler) {
            overrideSubmitHandler(__assign(__assign({}, updatedMessage), { parent: parent }), channel.cid);
            dispatch({ type: 'clear' });
        }
        else if (sendMessage) {
            var sendMessagePromise = sendMessage(__assign(__assign({}, updatedMessage), { parent: parent }));
            logChatPromiseExecution(sendMessagePromise, 'send message');
            dispatch({ type: 'clear' });
        }
        if (publishTypingEvent)
            logChatPromiseExecution(channel.stopTyping(), 'stop typing');
    };
    return {
        handleSubmit: handleSubmit,
    };
};

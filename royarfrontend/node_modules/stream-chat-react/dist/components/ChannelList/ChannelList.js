var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import React, { useEffect, useRef, useState } from 'react';
import { ChannelListMessenger } from './ChannelListMessenger';
import { useChannelDeletedListener } from './hooks/useChannelDeletedListener';
import { useChannelHiddenListener } from './hooks/useChannelHiddenListener';
import { useChannelTruncatedListener } from './hooks/useChannelTruncatedListener';
import { useChannelUpdatedListener } from './hooks/useChannelUpdatedListener';
import { useChannelVisibleListener } from './hooks/useChannelVisibleListener';
import { useConnectionRecoveredListener } from './hooks/useConnectionRecoveredListener';
import { useMessageNewListener } from './hooks/useMessageNewListener';
import { useMobileNavigation } from './hooks/useMobileNavigation';
import { useNotificationAddedToChannelListener } from './hooks/useNotificationAddedToChannelListener';
import { useNotificationMessageNewListener } from './hooks/useNotificationMessageNewListener';
import { useNotificationRemovedFromChannelListener } from './hooks/useNotificationRemovedFromChannelListener';
import { usePaginatedChannels } from './hooks/usePaginatedChannels';
import { useUserPresenceChangedListener } from './hooks/useUserPresenceChangedListener';
import { MAX_QUERY_CHANNELS_LIMIT, moveChannelUp } from './utils';
import { Avatar as DefaultAvatar } from '../Avatar/Avatar';
import { ChannelPreview } from '../ChannelPreview/ChannelPreview';
import { ChannelSearch as DefaultChannelSearch, } from '../ChannelSearch/ChannelSearch';
import { ChatDown } from '../ChatDown/ChatDown';
import { EmptyStateIndicator as DefaultEmptyStateIndicator, } from '../EmptyStateIndicator';
import { LoadingChannels } from '../Loading/LoadingChannels';
import { LoadMorePaginator } from '../LoadMore/LoadMorePaginator';
import { useChatContext } from '../../context/ChatContext';
var DEFAULT_FILTERS = {};
var DEFAULT_OPTIONS = {};
var DEFAULT_SORT = {};
var UnMemoizedChannelList = function (props) {
    var additionalChannelSearchProps = props.additionalChannelSearchProps, _a = props.Avatar, Avatar = _a === void 0 ? DefaultAvatar : _a, allowNewMessagesFromUnfilteredChannels = props.allowNewMessagesFromUnfilteredChannels, channelRenderFilterFn = props.channelRenderFilterFn, _b = props.ChannelSearch, ChannelSearch = _b === void 0 ? DefaultChannelSearch : _b, customActiveChannel = props.customActiveChannel, _c = props.EmptyStateIndicator, EmptyStateIndicator = _c === void 0 ? DefaultEmptyStateIndicator : _c, filters = props.filters, _d = props.LoadingErrorIndicator, LoadingErrorIndicator = _d === void 0 ? ChatDown : _d, _e = props.LoadingIndicator, LoadingIndicator = _e === void 0 ? LoadingChannels : _e, _f = props.List, List = _f === void 0 ? ChannelListMessenger : _f, lockChannelOrder = props.lockChannelOrder, onAddedToChannel = props.onAddedToChannel, onChannelDeleted = props.onChannelDeleted, onChannelHidden = props.onChannelHidden, onChannelTruncated = props.onChannelTruncated, onChannelUpdated = props.onChannelUpdated, onChannelVisible = props.onChannelVisible, onMessageNew = props.onMessageNew, onRemovedFromChannel = props.onRemovedFromChannel, options = props.options, _g = props.Paginator, Paginator = _g === void 0 ? LoadMorePaginator : _g, Preview = props.Preview, _h = props.sendChannelsToList, sendChannelsToList = _h === void 0 ? false : _h, _j = props.setActiveChannelOnMount, setActiveChannelOnMount = _j === void 0 ? true : _j, _k = props.showChannelSearch, showChannelSearch = _k === void 0 ? false : _k, _l = props.sort, sort = _l === void 0 ? DEFAULT_SORT : _l, _m = props.watchers, watchers = _m === void 0 ? {} : _m;
    var _o = useChatContext(), channel = _o.channel, client = _o.client, closeMobileNav = _o.closeMobileNav, _p = _o.navOpen, navOpen = _p === void 0 ? false : _p, setActiveChannel = _o.setActiveChannel, theme = _o.theme, useImageFlagEmojisOnWindows = _o.useImageFlagEmojisOnWindows;
    var channelListRef = useRef(null);
    var _q = useState(0), channelUpdateCount = _q[0], setChannelUpdateCount = _q[1];
    /**
     * Set a channel with id {customActiveChannel} as active and move it to the top of the list.
     * If customActiveChannel prop is absent, then set the first channel in list as active channel.
     */
    var activeChannelHandler = function (channels, setChannels) {
        if (!channels ||
            channels.length === 0 ||
            channels.length > ((options === null || options === void 0 ? void 0 : options.limit) || MAX_QUERY_CHANNELS_LIMIT)) {
            return;
        }
        if (customActiveChannel) {
            var customActiveChannelObject = channels.find(function (chan) { return chan.id === customActiveChannel; });
            if (customActiveChannelObject) {
                if (setActiveChannel) {
                    setActiveChannel(customActiveChannelObject, watchers);
                }
                var newChannels = moveChannelUp(customActiveChannelObject.cid, channels);
                setChannels(newChannels);
            }
            return;
        }
        if (setActiveChannelOnMount && setActiveChannel) {
            setActiveChannel(channels[0], watchers);
        }
    };
    /**
     * For some events, inner properties on the channel will update but the shallow comparison will not
     * force a re-render. Incrementing this dummy variable ensures the channel previews update.
     */
    var forceUpdate = function () { return setChannelUpdateCount(function (count) { return count + 1; }); };
    var _r = usePaginatedChannels(client, filters || DEFAULT_FILTERS, sort || DEFAULT_SORT, options || DEFAULT_OPTIONS, activeChannelHandler), channels = _r.channels, hasNextPage = _r.hasNextPage, loadNextPage = _r.loadNextPage, setChannels = _r.setChannels, setOffset = _r.setOffset, status = _r.status;
    var loadedChannels = channelRenderFilterFn ? channelRenderFilterFn(channels) : channels;
    useMobileNavigation(channelListRef, navOpen, closeMobileNav);
    useMessageNewListener(setChannels, lockChannelOrder, allowNewMessagesFromUnfilteredChannels);
    useNotificationMessageNewListener(setChannels, onMessageNew, setOffset);
    useNotificationAddedToChannelListener(setChannels, onAddedToChannel);
    useNotificationRemovedFromChannelListener(setChannels, onRemovedFromChannel);
    useChannelDeletedListener(setChannels, onChannelDeleted);
    useChannelHiddenListener(setChannels, onChannelHidden);
    useChannelVisibleListener(setChannels, onChannelVisible);
    useChannelTruncatedListener(setChannels, onChannelTruncated, forceUpdate);
    useChannelUpdatedListener(setChannels, onChannelUpdated, forceUpdate);
    useConnectionRecoveredListener(forceUpdate);
    useUserPresenceChangedListener(setChannels);
    useEffect(function () {
        var handleEvent = function (event) {
            if (setActiveChannel && (event === null || event === void 0 ? void 0 : event.cid) === (channel === null || channel === void 0 ? void 0 : channel.cid)) {
                setActiveChannel();
            }
        };
        client.on('channel.deleted', handleEvent);
        client.on('channel.hidden', handleEvent);
        return function () {
            client.off('channel.deleted', handleEvent);
            client.off('channel.hidden', handleEvent);
        };
    }, [channel]);
    var renderChannel = function (item) {
        if (!item)
            return null;
        var previewProps = {
            activeChannel: channel,
            Avatar: Avatar,
            channel: item,
            channelUpdateCount: channelUpdateCount,
            key: item.id,
            Preview: Preview,
            setActiveChannel: setActiveChannel,
            watchers: watchers,
        };
        return React.createElement(ChannelPreview, __assign({}, previewProps));
    };
    var renderList = function () { return (React.createElement(List, { error: status.error, loadedChannels: sendChannelsToList ? loadedChannels : undefined, loading: status.loadingChannels, LoadingErrorIndicator: LoadingErrorIndicator, LoadingIndicator: LoadingIndicator }, !loadedChannels || loadedChannels.length === 0 ? (React.createElement(EmptyStateIndicator, { listType: 'channel' })) : (React.createElement(Paginator, { hasNextPage: hasNextPage, loadNextPage: loadNextPage, refreshing: status.refreshing }, loadedChannels.map(renderChannel))))); };
    return (React.createElement(React.Fragment, null,
        React.createElement("div", { className: "str-chat str-chat-channel-list " + theme + " " + (navOpen ? 'str-chat-channel-list--open' : '') + " " + (useImageFlagEmojisOnWindows && navigator.platform.match(/Win/)
                ? 'str-chat--windows-flags'
                : ''), ref: channelListRef },
            showChannelSearch && React.createElement(ChannelSearch, __assign({}, additionalChannelSearchProps)),
            renderList())));
};
/**
 * Renders a preview list of Channels, allowing you to select the Channel you want to open
 */
export var ChannelList = React.memo(UnMemoizedChannelList);

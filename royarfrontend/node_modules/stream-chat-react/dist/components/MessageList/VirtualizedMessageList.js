var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import React, { useCallback, useEffect, useMemo, useRef } from 'react';
import { Virtuoso, } from 'react-virtuoso';
import { useNewMessageNotification } from './hooks/useNewMessageNotification';
import { usePrependedMessagesCount } from './hooks/usePrependMessagesCount';
import { useShouldForceScrollToBottom } from './hooks/useShouldForceScrollToBottom';
import { MessageNotification as DefaultMessageNotification } from './MessageNotification';
import { processMessages } from './utils';
import { DateSeparator as DefaultDateSeparator } from '../DateSeparator/DateSeparator';
import { EmptyStateIndicator as DefaultEmptyStateIndicator } from '../EmptyStateIndicator/EmptyStateIndicator';
import { EventComponent } from '../EventComponent/EventComponent';
import { LoadingIndicator as DefaultLoadingIndicator } from '../Loading/LoadingIndicator';
import { FixedHeightMessage } from '../Message/FixedHeightMessage';
import { Message } from '../Message/Message';
import { useChannelActionContext, } from '../../context/ChannelActionContext';
import { useChannelStateContext } from '../../context/ChannelStateContext';
import { useChatContext } from '../../context/ChatContext';
import { useComponentContext } from '../../context/ComponentContext';
import { isDate, useTranslationContext } from '../../context/TranslationContext';
var PREPEND_OFFSET = Math.pow(10, 7);
var VirtualizedMessageListWithContext = function (props) {
    var channel = props.channel, client = props.client, customMessageRenderer = props.customMessageRenderer, _a = props.disableDateSeparator, disableDateSeparator = _a === void 0 ? true : _a, hasMore = props.hasMore, _b = props.hideDeletedMessages, hideDeletedMessages = _b === void 0 ? false : _b, _c = props.hideNewMessageSeparator, hideNewMessageSeparator = _c === void 0 ? false : _c, loadingMore = props.loadingMore, loadMore = props.loadMore, propMessage = props.Message, _d = props.messageLimit, messageLimit = _d === void 0 ? 100 : _d, messages = props.messages, _e = props.overscan, overscan = _e === void 0 ? 0 : _e, 
    // TODO: refactor to scrollSeekPlaceHolderConfiguration and components.ScrollSeekPlaceholder, like the Virtuoso Component
    scrollSeekPlaceHolder = props.scrollSeekPlaceHolder, _f = props.scrollToLatestMessageOnFocus, scrollToLatestMessageOnFocus = _f === void 0 ? false : _f, _g = props.shouldGroupByUser, shouldGroupByUser = _g === void 0 ? false : _g, _h = props.stickToBottomScrollBehavior, stickToBottomScrollBehavior = _h === void 0 ? 'smooth' : _h;
    var _j = useComponentContext(), _k = _j.DateSeparator, DateSeparator = _k === void 0 ? DefaultDateSeparator : _k, _l = _j.EmptyStateIndicator, EmptyStateIndicator = _l === void 0 ? DefaultEmptyStateIndicator : _l, _m = _j.LoadingIndicator, LoadingIndicator = _m === void 0 ? DefaultLoadingIndicator : _m, _o = _j.MessageNotification, MessageNotification = _o === void 0 ? DefaultMessageNotification : _o, _p = _j.MessageSystem, MessageSystem = _p === void 0 ? EventComponent : _p, _q = _j.TypingIndicator, TypingIndicator = _q === void 0 ? null : _q, _r = _j.VirtualMessage, contextMessage = _r === void 0 ? FixedHeightMessage : _r;
    var t = useTranslationContext().t;
    var lastRead = useMemo(function () { var _a; return (_a = channel.lastRead) === null || _a === void 0 ? void 0 : _a.call(channel); }, [channel]);
    var MessageUIComponent = propMessage || contextMessage;
    var processedMessages = useMemo(function () {
        if (typeof messages === 'undefined') {
            return [];
        }
        if (disableDateSeparator && !hideDeletedMessages && hideNewMessageSeparator) {
            return messages;
        }
        return processMessages(messages, lastRead, client.userID, hideDeletedMessages, disableDateSeparator, hideNewMessageSeparator);
    }, [
        disableDateSeparator,
        hideDeletedMessages,
        hideNewMessageSeparator,
        lastRead,
        messages,
        messages === null || messages === void 0 ? void 0 : messages.length,
        client.userID,
    ]);
    var virtuoso = useRef(null);
    var _s = useNewMessageNotification(processedMessages, client.userID), atBottom = _s.atBottom, newMessagesNotification = _s.newMessagesNotification, setNewMessagesNotification = _s.setNewMessagesNotification;
    var scrollToBottom = useCallback(function () {
        if (virtuoso.current) {
            virtuoso.current.scrollToIndex(processedMessages.length - 1);
        }
        setNewMessagesNotification(false);
    }, [virtuoso, processedMessages, setNewMessagesNotification, processedMessages.length]);
    var scrollToBottomIfConfigured = useCallback(function (event) {
        if (scrollToLatestMessageOnFocus && event.target === window) {
            setTimeout(scrollToBottom, 100);
        }
    }, [scrollToLatestMessageOnFocus, scrollToBottom]);
    useEffect(function () {
        if (typeof window !== 'undefined') {
            window.addEventListener('focus', scrollToBottomIfConfigured);
        }
        return function () { return window.removeEventListener('focus', scrollToBottomIfConfigured); };
    }, [scrollToBottomIfConfigured]);
    var numItemsPrepended = usePrependedMessagesCount(processedMessages);
    var shouldForceScrollToBottom = useShouldForceScrollToBottom(processedMessages, client.userID);
    var messageRenderer = useCallback(function (messageList, virtuosoIndex) {
        var streamMessageIndex = virtuosoIndex + numItemsPrepended - PREPEND_OFFSET;
        // use custom renderer supplied by client if present and skip the rest
        if (customMessageRenderer) {
            return customMessageRenderer(messageList, streamMessageIndex);
        }
        var message = messageList[streamMessageIndex];
        if (message.customType === 'message.date' && message.date && isDate(message.date)) {
            return React.createElement(DateSeparator, { date: message.date, unread: message.unread });
        }
        if (!message)
            return React.createElement("div", { style: { height: '1px' } }); // returning null or zero height breaks the virtuoso
        if (message.type === 'system') {
            return React.createElement(MessageSystem, { message: message });
        }
        return (React.createElement(Message, { message: message, Message: function () {
                var _a, _b;
                return (React.createElement(MessageUIComponent, { groupedByUser: shouldGroupByUser &&
                        streamMessageIndex > 0 &&
                        ((_a = message.user) === null || _a === void 0 ? void 0 : _a.id) === ((_b = messageList[streamMessageIndex - 1].user) === null || _b === void 0 ? void 0 : _b.id) }));
            } }));
    }, [customMessageRenderer, shouldGroupByUser, numItemsPrepended]);
    var virtuosoComponents = useMemo(function () {
        var EmptyPlaceholder = function () { return (React.createElement(React.Fragment, null, EmptyStateIndicator && React.createElement(EmptyStateIndicator, { listType: 'message' }))); };
        var Header = function () {
            return loadingMore ? (React.createElement("div", { className: 'str-chat__virtual-list__loading' },
                React.createElement(LoadingIndicator, { size: 20 }))) : (React.createElement(React.Fragment, null));
        };
        // using 'display: inline-block' traps CSS margins of the item elements, preventing incorrect item measurements
        var Item = function (props) { return (React.createElement("div", __assign({}, props, { className: 'str-chat__virtual-list-message-wrapper' }))); };
        var Footer = function () {
            return TypingIndicator ? React.createElement(TypingIndicator, { avatarSize: 24 }) : React.createElement(React.Fragment, null);
        };
        return {
            EmptyPlaceholder: EmptyPlaceholder,
            Footer: Footer,
            Header: Header,
            Item: Item,
        };
    }, [loadingMore]);
    if (!processedMessages)
        return null;
    return (React.createElement("div", { className: 'str-chat__virtual-list' },
        React.createElement(Virtuoso, __assign({ atBottomStateChange: function (isAtBottom) {
                atBottom.current = isAtBottom;
                if (isAtBottom && newMessagesNotification) {
                    setNewMessagesNotification(false);
                }
            }, components: virtuosoComponents, firstItemIndex: PREPEND_OFFSET - numItemsPrepended, followOutput: function (isAtBottom) {
                if (shouldForceScrollToBottom()) {
                    return isAtBottom ? stickToBottomScrollBehavior : 'auto';
                }
                // a message from another user has been received - don't scroll to bottom unless already there
                return isAtBottom ? stickToBottomScrollBehavior : false;
            }, initialTopMostItemIndex: processedMessages && processedMessages.length > 0 ? processedMessages.length - 1 : 0, itemContent: function (i) { return messageRenderer(processedMessages, i); }, overscan: overscan, ref: virtuoso, startReached: function () {
                if (hasMore && loadMore) {
                    loadMore(messageLimit);
                }
            }, style: { overflowX: 'hidden' }, totalCount: processedMessages.length }, (scrollSeekPlaceHolder ? { scrollSeek: scrollSeekPlaceHolder } : {}))),
        React.createElement("div", { className: 'str-chat__list-notifications' },
            React.createElement(MessageNotification, { onClick: scrollToBottom, showNotification: newMessagesNotification }, t('New Messages!')))));
};
/**
 * The VirtualizedMessageList component renders a list of messages in a virtualized list.
 * It is a consumer of the React contexts set in [Channel](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Channel/Channel.tsx).
 *
 * **Note**: It works well when there are thousands of messages in a channel, it has a shortcoming though - the message UI should have a fixed height.
 */
export function VirtualizedMessageList(props) {
    var loadMore = useChannelActionContext().loadMore;
    var _a = useChannelStateContext(), channel = _a.channel, hasMore = _a.hasMore, loadingMore = _a.loadingMore, contextMessages = _a.messages;
    var client = useChatContext().client;
    var messages = props.messages || contextMessages;
    return (React.createElement(VirtualizedMessageListWithContext, __assign({ channel: channel, client: client, hasMore: !!hasMore, loadingMore: !!loadingMore, loadMore: loadMore, messages: messages }, props)));
}
